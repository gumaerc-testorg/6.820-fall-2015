---
content_type: page
description: This section provides the schedule of course topics, readings, and assignment
  due dates.
learning_resource_types:
- Readings
ocw_type: CourseSection
title: Calendar & Readings
uid: 87f29f92-0af6-3dd8-fa06-ba83153507b2
---

{{< tableopen >}}
{{< theadopen >}}
{{< tropen >}}
{{< thopen >}}
SES #
{{< thclose >}}
{{< thopen >}}
TOPICS
{{< thclose >}}
{{< thopen >}}
READINGS
{{< thclose >}}
{{< thopen >}}
KEY DATES
{{< thclose >}}

{{< trclose >}}

{{< theadclose >}}
{{< tropen >}}
{{< tdopen colspan="4" >}}
**Unit 1: Intro to Functional Programming & Operational Semantics**
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
1
{{< tdclose >}}
{{< tdopen >}}
Introduction to Functional Programming and Types
{{< tdclose >}}
{{< tdopen >}}


Some interesting reading about the genesis of functional programming:

Backus, John. "{{% resource_link "5b337a2a-00fa-4002-83d9-e926ca1b5aae" "Can Programming be Liberated from the Von Neumann Style? A Functional Style and its Algebra of Programs" %}}." _Magazine Communications of the ACM_ 8, no. 21 (1978): 613–41.

Hudak, Hughes, Peyton Jones, et al. {{% resource_link "99140b9f-ee32-4a7d-a633-6e81bbad85db" "\"A History of Haskell: Being Lazy With Class.\" (PDF)" %}} 2007.


{{< tdclose >}}
{{< tdopen >}}
Problem Set 1 Out
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
2
{{< tdclose >}}
{{< tdopen >}}
Lambda Calculus
{{< tdclose >}}
{{< tdopen >}}


Suggested Reading:

{{% resource_link "9759ea9b-1872-4569-9c70-7c309474703c" "![Buy at MIT Press](/images/mp_logo.gif)" %}} Pierce, Benjamin C. Chapter 5 in _Types and Programming Languages_. MIT Press, 2002. ISBN: 9780262162098. \[Preview with {{% resource_link "a0437b96-c575-4839-b144-5bdc062b574e" "Google Books" %}}\]


{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
3
{{< tdclose >}}
{{< tdopen >}}
Big-Step vs. Small-Step Semantics and the λLet Calculus
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
4
{{< tdclose >}}
{{< tdopen >}}
Coq Crash Course (Examples in Operational Semantics)
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}
{{< tdopen >}}
Problem Set 1 due
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen colspan="4" >}}
**Unit 2: Type Theory**
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
5
{{< tdclose >}}
{{< tdopen >}}
Introduction to Simple Types
{{< tdclose >}}
{{< tdopen >}}


{{% resource_link "9759ea9b-1872-4569-9c70-7c309474703c" "![Buy at MIT Press](/images/mp_logo.gif)" %}} Cardelli's, Luca. "Type Systems." In _Types and Programming Languages_. MIT Press, 2002. ISBN: 9780262162098.


{{< tdclose >}}
{{< tdopen >}}
Problem Set 2 Out
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
6
{{< tdclose >}}
{{< tdopen >}}
Hindley-Milner Type Inference and Polymorphic Types
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
7
{{< tdclose >}}
{{< tdopen >}}
Algebraic Data Types & Their Ingredients: Product, Sum, and Recursive Types
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
8
{{< tdclose >}}
{{< tdopen >}}
Type Classes and Subtyping
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen colspan="4" >}}
**Unit 3: Types for Imperative Programs**
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
9
{{< tdclose >}}
{{< tdopen >}}
Monads
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}
{{< tdopen >}}


Problem Set 2 due

Problem Set 3 Out


{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
10
{{< tdclose >}}
{{< tdopen >}}
Typing of Imperative Programs
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
11
{{< tdclose >}}
{{< tdopen >}}
Verification of Complex Properties with Types: From Information Flow to Race Detection
{{< tdclose >}}
{{< tdopen >}}


Myers, A. C. "{{% resource_link "1045adac-9938-4872-8b2b-ddb3e1a5a498" "JFlow: Practical Mostly-static Information Flow Control" %}}." _Principles of Programming Languages_ (1999): 228–41.

Flanagan, C., and S. N. Freund. "{{% resource_link "6e0eb263-6b70-471c-8373-ed245e53592e" "Type-based Race Detection for Java" %}}." _ACM SIGPLAN Notices_ 35, no. 5 (2000): 219–32.


{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen colspan="4" >}}
**Unit 4: Axiomatic Semantics**
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
12
{{< tdclose >}}
{{< tdopen >}}
Intro to Axiomatic Semantics
{{< tdclose >}}
{{< tdopen >}}


Floyd, Robert. {{% resource_link "873fb211-6e7a-4f57-8172-796bf8cff8ac" "\"Assigning Meanings to Programs.\" (PDF)" %}}


{{< tdclose >}}
{{< tdopen >}}
Problem Set 4 Out
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
13
{{< tdclose >}}
{{< tdopen >}}
Verification Condition Generation
{{< tdclose >}}
{{< tdopen >}}
Hoare. "{{% resource_link "8b941cff-99be-44f5-b06f-126fb8428e46" "An Axiomatic Basis for Computer Programming" %}}." _Communications of the ACM_ 12, no. 10 (1969): 576–80.
{{< tdclose >}}
{{< tdopen >}}
Problem Set 3 due
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
14
{{< tdclose >}}
{{< tdopen >}}
Total Correctness and Termination
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
15
{{< tdclose >}}
{{< tdopen >}}
Separation Logic
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
16
{{< tdclose >}}
{{< tdopen >}}
Axiomatic Semantics for Concurrency: Rely-Guarantee & Concurrent Separation Logic
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen colspan="4" >}}
**Unit 5: Abstract Interpretation**
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
17
{{< tdclose >}}
{{< tdopen >}}
Dataflow Analysis, Lattices, Fixed Points
{{< tdclose >}}
{{< tdopen >}}
Kildall, Gary. "{{% resource_link "f6b8cb2a-dbc3-4366-8d23-0d8466fe3530" "A Unified Approach to Global Program Optimization" %}}." _Principles of Programming Languages_ (1973): 194–206.
{{< tdclose >}}
{{< tdopen >}}


Problem Set 4 due

Problem Set 5 Out


{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
18
{{< tdclose >}}
{{< tdopen >}}
Abstract Interpretation, Galois Connections
{{< tdclose >}}
{{< tdopen >}}
Cousot, P., and R. Cousot. "{{% resource_link "54b6ee3b-47bd-4303-b484-0adf0fb75aa3" "Abstract Interpretation: A Unified Lattice Model for Static analysis of Programs by Construction or Approximation of Fixpoints" %}}." _Principles of Programming Languages_ (1977): 238–52.
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
19
{{< tdclose >}}
{{< tdopen >}}
Abstract Interpretation, Galois Connections (cont.)
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
20
{{< tdclose >}}
{{< tdopen >}}
The Heap: Inferring Loop Invariants About Data Structure Shape
{{< tdclose >}}
{{< tdopen >}}


Sagiv, Reps, et al. "{{% resource_link "2db946ff-ce17-42f4-a863-17e9637889b0" "Solving Shape-Analysis Problems in Languages with Destructive Updating" %}}." _Principles of Programming Languages_ 20, no. 1 (1993): 1–50.


{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen colspan="4" >}}
**Unit 6: Model Checking**
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
21
{{< tdclose >}}
{{< tdopen >}}
Intro to Models and Properties
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
22
{{< tdclose >}}
{{< tdopen >}}
Temporal Logic
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}
{{< tdopen >}}
Problem Set 5 due
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
23
{{< tdclose >}}
{{< tdopen >}}
Explicit State Model Checking
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}
{{< tdopen >}}
Problem Set 6 Out
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
24
{{< tdclose >}}
{{< tdopen >}}
Symbolic Model Checking
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
25
{{< tdclose >}}
{{< tdopen >}}
Software Model Checking with Abstraction Refinement
{{< tdclose >}}
{{< tdopen >}}


Henzinger, T. A., R. Jhala, et al. "{{% resource_link "bad85aba-153a-4fc8-8b4c-193b63d0f8fa" "Lazy Abstraction" %}}." _Principles of Programming Languages ACM_ 37, no. 1 (2002): 58–70.

Ball, T., R. Majumdar, et al. "{{% resource_link "28d2b217-ea70-4c30-bc5f-fae0a278cfa1" "Automatic Predicate Abstraction of C Programs" %}}." _ACM SIGPLAN Notices_ 36, no. 5 (2001): 203–13.


{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
26
{{< tdclose >}}
{{< tdopen >}}
From Model Checking to Synthesis
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}
{{< tdopen >}}
Problem Set 6 due
{{< tdclose >}}

{{< trclose >}}

{{< tableclose >}}